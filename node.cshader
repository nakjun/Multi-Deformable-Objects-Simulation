#version 430

struct BoundingBox
{
   vec3 Min;
   vec3 Max;   
   int Objectindex; 
   int CurrLevel;
   int ParentLevel; 
};

// Target 0 : Vertex position
layout(std430, binding = 0) buffer Pos {
   vec4 Positions[];
};

// Target 12 : Previous Vertex position
layout(std430, binding = 12) buffer PrevPos {
   vec4 PrevPositions[];
};

// Target 1 : Vertex velocity
layout(std430, binding = 1) buffer Vel {
    vec4 Velocities[];
};

//Target 4 :Particle Force
layout(std430, binding =3)  buffer NodeForce{
	vec4 Node_Force[];
};

//Target 6 : Bounding Box Collision Result
layout(std430, binding =5)  buffer Res{
	vec4 BB_RES[];
};

// Target 6 : Vertex Normal
layout(std430, binding = 6) buffer NormalB {
   vec4 Normal[];
};

layout(std430, binding =8)  buffer ObjectInformation{
	vec4 O_Infor[];
};

layout (local_size_x = 512) in;

// Object's Vertex Count
uniform int VertexCount;
uniform int ObjectCount;

float dt=0.0005;

vec3 gravity = vec3(9.8, 0.0f,0.0);
//vec3 gravity = vec3(0.0, -9.8f,0.0);

void main() {

	uint index = gl_GlobalInvocationID.x;
	
	if(index>=VertexCount) return;

	// 위치와 속도 읽기
	vec3 vPos = Positions[index].xyz;
	
	PrevPositions[index].xyz = vPos;

	vec3 vVel = Velocities[index].xyz;	
	
	float vCollisionFlag = Normal[index].w;
	
	int obj = int(Positions[index].w);
	
	if(obj==1) gravity.x *= -0.5;

	vec3 Force = Node_Force[index * 30 + 30].xyz;
	
	vec3 a = gravity + ( Force / 1.0f);
		
	vVel = vVel + a * dt ;

	vPos += vVel * dt;
  
    //Status Update   
    Positions[index].xyz = vPos;   
    Velocities[index].xyz = vVel;	
}