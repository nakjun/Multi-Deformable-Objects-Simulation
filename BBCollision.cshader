#version 430
// 0 : Node Position, 1 : Node Velocity, 2 : Spring Information, 3 : Node Force, 4 : BBInformation, 5 : BBResult, 6 : Normal, 7 : Face Information
struct BoundingBox
{
   vec4 Min;
   vec4 Max;   
   vec4 data;   
};

struct FaceInformation
{
	vec4 FaceNodeIndex;
	vec4 FaceNodeLocation;
};

// Target 4 : Bounding Box Information
layout(std430, binding = 4) buffer BBInfor {
    BoundingBox BB_INFOR1[]; 
};

//Target 5 : Bounding Box Collision Result
layout(std430, binding =5)  buffer Res{
	vec4 BB_RES[];
};

// Target 6 : Vertex Normal
layout(std430, binding = 6) buffer NormalB {
   vec4 Normal[];
};

//Target 8 : ObjectInformation
layout(std430, binding =8)  buffer OBJECT{
	vec4 ObjectInformation[];
};

//Target 11 : Masking Table
layout(std430, binding =11)  buffer Mask{
	int MaskResult[];
};

//Target 7 : Face INformation
layout(std430, binding =7)  buffer FACE{
	FaceInformation Face_Information[];	
};

// Target 9 : Bounding Box Face Information
layout(std430, binding = 9) buffer BB_Face {
    vec4 BBFaceList[]; 
};

float check(vec3 min1,vec3 min2,vec3 max1,vec3 max2){
	if (max1.x < min2.x || min1.x > max2.x) return 0.0;
	if (max1.y < min2.y || min1.y > max2.y) return 0.0;
	if (max1.z < min2.z || min1.z > max2.z) return 0.0;
	return 1.0;
}

uniform int BBCount;
uniform int FaceOffset;
//uniform int 

layout (local_size_x = 32, local_size_y = 32) in;

void main()
{	
	//INVOKED BOUNDING BOX INDEX(x,y)
	uint index1= gl_GlobalInvocationID.x;
	uint index2= gl_GlobalInvocationID.y;		
	
	//BB가 소속된 OBJECT의 INDEX를 가져옴
	int BBINDEX1 = int(BB_INFOR1[index1].data.x);
	int BBINDEX2 = int(BB_INFOR1[index2].data.x);

	//BB가 소속된 INDEX가 같을 경우 쓰레드 종료
	if(BBINDEX1==BBINDEX2) return;

	//INVOKE된 BB1의 INDEX가 BB2보다 작을 경우 쓰레드 종료(절반만 수행하도록 설정)
	if(index1<index2) return;

	//BB가 가지고있는 FACE의 갯수를 가져옴
	int nowfaceCount1 = int(BB_INFOR1[index1].data.w);
	int nowfaceCount2 = int(BB_INFOR1[index2].data.w);
		
	//BB간 충돌 결과를 저장할 MASK를 초기화함(-1)
	MaskResult[(64*BBINDEX1)+index1+(64*BBINDEX2)+index2] = -1;

	if(nowfaceCount1==0 || nowfaceCount2==0) return;

	//충돌 검사 수행 및 결과 저장
	float res = check(BB_INFOR1[index1].Min.xyz,BB_INFOR1[index2].Min.xyz,BB_INFOR1[index1].Max.xyz,BB_INFOR1[index2].Max.xyz);		
	
	//MASKRESULT SSBO에 결과 값 저장
	MaskResult[(64*BBINDEX1)+index1+(64*BBINDEX2)+index2] = int(res);
}