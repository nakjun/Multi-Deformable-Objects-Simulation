#version 430
layout( local_size_x = 32, local_size_y = 32) in;
layout(std430, binding=0) buffer PosIn {
  vec4 PositionIn[];
};
struct FaceInformation
{
	vec4 FaceNodeIndex;
	vec4 FaceNodeLocation;
};
// Target 12 : Previous Vertex position
layout(std430, binding = 12) buffer PrevPos {
   vec4 PrevPositions[];
};

// Target 1 : Vertex velocity
layout(std430, binding = 1) buffer Vel {
    vec4 Velocities[];
};

// Target 6 : Vertex Normal
layout(std430, binding = 6) buffer NormalB {
   vec4 Normal[];
};

layout(std430, binding=7) buffer FaceInfor {
  FaceInformation Face_Information[];
};

// Target 9 : Bounding Box Face Information
layout(std430, binding = 9) buffer BB_Face {
    vec4 BBFaceList[]; 
};

layout(std430, binding=10) buffer Pairwise {
  vec4 FacePairwise[];
};

//Target 11 : Masking Table
layout(std430, binding =11)  buffer Mask{
	int MaskResult[];
};

float tolerance = 0.005;
uniform int Offset;
uniform int FaceOffset;
uniform int obj2facecount;

void main() {
	
	uint idx_x = gl_GlobalInvocationID.x;  
	uint idx_y = gl_GlobalInvocationID.y + Offset; 
    
	vec4 BB1 = BBFaceList[idx_x];
	vec4 BB2 = BBFaceList[idx_y];

	int bbindex1 = int(BB1.y);
	int bbindex2 = int(BB2.y);

	int faceIndex1 = int(BB1.x);
	int faceIndex2 = int(BB2.x) + FaceOffset;

	if(FacePairwise[faceIndex1*obj2facecount+faceIndex2].z!=1.0) return;

	vec3 tri1_node1 = Velocities[int(FaceInformation[faceIndex1].x)].xyz;
	vec3 tri1_node2 = Velocities[int(FaceInformation[faceIndex1].y)].xyz;
	vec3 tri1_node3 = Velocities[int(FaceInformation[faceIndex1].z)].xyz;

	vec3 tri2_node1 = Velocities[int(FaceInformation[faceIndex2].x)].xyz;
	vec3 tri2_node2 = Velocities[int(FaceInformation[faceIndex2].y)].xyz;
	vec3 tri2_node3 = Velocities[int(FaceInformation[faceIndex2].z)].xyz;
	
	vec3 VelocityAverageTri1 = (tri1_node1+tri1_node2+tri1_node3)/3.0;
	vec3 VelocityAverageTri2 = (tri2_node1+tri2_node2+tri2_node3)/3.0;
	
	//Calculate Reflect Vector

			
	FacePairwise[faceIndex1*obj2facecount+faceIndex2].z = 0.0;
}